var store = [{
        "title": "JAVA - String 타입의 두가지 생성 방식",
        "excerpt":"String 타입의 두가지 생성 방식  자바에서 String은 기본형처럼 사용하는 리터럴 방식과 참조형, 즉 객체와 같이 생성하는 new 연산자 생성 방식이 있다.   1. 리터럴 방식     new 연산자 없이 생성이 가능     1 String str = \"abcde\";           String constant pool 메모리 영역에 저장            String constant pool 메모리 영역은 heap 메모리영역 내의 별도 영역에 위치           대부분의 String 객체는 위와 같이 리터럴 방식으로 생성   리터럴 방식의 메모리 관리            상수풀에 문자열의 값이 없을 경우, 값을 저장 후 메모리 주소를 반환한다.       상수풀에 해당 문자열의 값이 있을 경우 해당 문자열의 메모리 주소를 반환한다.       따라서 변수가 다르더라도 문자열의 값이 가튼 경우 메모리 주소를 참조하게 한다.           2. new 연산자 생성 방식     참조형의 기본 객체 생성 방식과 같다.     1 String str = new String(\"abcde\");           다른 참조형 변수와 같이 Heap 메모리 영역에 저장한다.  ","categories": ["java"],
        "tags": ["java"],
        "url": "/java/java-new-String/",
        "teaser": null
      },{
        "title": "Blog - minimal mistake 사이드바 카테고리에 포스트 갯수 추가하기",
        "excerpt":"minimal mistake 사이드바 카테고리에 포스트 갯수 추가하기  초보자가 jekyll과 minimal mistake를 사용하여 블로그를 설정하는 것은 쉽지 않고, 공식 문서를 읽는 것은 고통스럽다. 다행히도 다른 분들이 블로그를 통해서 많은 정보를 공유해주신 덕분에 지금의 간단한 블로그를 설정할 수 있었다. 하지만 단 하나, 사이드바 카테고리에 포스트의 갯수를 추가하는 것은 다른 블로그에서 본대로 설정이 잘 되지 않았다. 그래서 스스로 코드를 변경해보았고, 그것을 공유한다.   사이드바 카테고리에 포스트 갯수?  왼쪽의 사이드바를 본다면 java(1)과 같이 카테고리에 포스팅 갯수가 표시되어 있는 것을 볼 수 있다.   다 필요 없고 코드나 보여주셈  말이 길었다. 전체 코드는 아래와 같다. _include폴더에 nav_list파일에 원래 내용을 지우고, 복사 붙여넣기 하면 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 {% assign navigation = site.data.navigation[include.nav] %} &lt;nav class=\"nav__list\"&gt;   {% if page.sidebar.title %}&lt;h3 class=\"nav__title\" style=\"padding-left: 0;\"&gt;{{ page.sidebar.title }}&lt;/h3&gt;{% endif %}   &lt;input id=\"ac-toc\" name=\"accordion-toc\" type=\"checkbox\" /&gt;   &lt;label for=\"ac-toc\"&gt;{{ site.data.ui-text[site.locale].menu_label | default: \"Toggle Menu\" }}&lt;/label&gt;   &lt;ul class=\"nav__items\"&gt;     {% for nav in navigation %}       &lt;li&gt;         {% if nav.url %}           &lt;a href=\"{{ nav.url | relative_url }}\"&gt;&lt;span class=\"nav__sub-title\"&gt;{{ nav.title }}&lt;/span&gt;&lt;/a&gt;         {% else %}           &lt;span class=\"nav__sub-title\"&gt;{{ nav.title }}&lt;/span&gt;         {% endif %}          {% if nav.children != null %}         &lt;ul&gt;           {% for child in nav.children %}           {% assign category = site.categories.[child.title] | where_exp: \"item\", \"item.hidden != true\" %}             {%if category.size == null %}               &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }} (0)&lt;/a&gt;&lt;/li&gt;             {% else %}               &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }} ({{category.size}})&lt;/a&gt;&lt;/li&gt;             {% endif %}           {% endfor %}         &lt;/ul&gt;         {% endif %}       &lt;/li&gt;     {% endfor %}   &lt;/ul&gt; &lt;/nav&gt;   약간의 설명  원래 코드에서 바뀐 부분은 17번쨰 줄의 for문 안이다.   원본   1 2 3           {% for child in nav.children %}             &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }}&lt;/a&gt;&lt;/li&gt;           {% endfor %}   바뀐 부분   1 2 3 4 5 6 7 8           {% for child in nav.children %}             {% assign category = site.categories.[child.title] | where_exp: \"item\", \"item.hidden != true\" %}             {%if category.size == null %}               &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }} (0)&lt;/a&gt;&lt;/li&gt;             {% else %}               &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }} ({{category.size}})&lt;/a&gt;&lt;/li&gt;             {% endif %}           {% endfor %}   각각의 카테고리를 찾은 뒤, if, else문을 사용하여 포스트가 아직 올라오지 않은 카테고리에는 0이 추가되고, 글이 있는 카테고리에는 포스트의 갯수를 추가해주었다.   (여러 시도를 통하여 변수를 수정하다가 만든 코드라 문제가 있을 수 있습니다. 문제가 있다면 저도 알려주시기를 부탁드립니다.)  ","categories": ["Blog"],
        "tags": ["blog","jekyll","minimal mistake","sidebar navigation","sidebar navigation 포스팅 수"],
        "url": "/blog/blog-nav-list-post-number/",
        "teaser": null
      },{
        "title": "JAVA - ChoiceFormat",
        "excerpt":"ChoiceFormat   ⚠ 이 글은 '자바의 정석'과 다른 인터넷의 글들을 참고하여 작성되었습니다 ⚠      ChoiceFormat은 특정 범위에 속하는 값을 문자열로 변환해준다.   연속적 또는 불연속적인 범위의 값들을 처리하는 데 있어서 if문이나 switch문은 적절하지 못한 경우가 많은데, ChoiceFormat을 사용하면 값을 간단하고 직관적으로 문자열로 변환할 수 있다.   두 개의 배열 사용  예시1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.text.ChoiceFormat;  public class ChoiceFormatEx1 {     public static void main(String[] args){         double[] limits = {60, 70, 80, 90};//낮은 값부터 큰 값의 순서로 적어야한다.         //limits, grade간의 순서를 맞추어야 한다.         String[] grades = {\"D\", \"C\", \"B\", \"A\"};          int[] scores = {100, 95, 88, 70, 52, 60, 70};          ChoiceFormat form = new ChoiceFormat(limits, grades);          for(int i = 0;i &lt; scores.length;i++){             System.out.println(scores[i]+\":\"+form.format(scores[i]));         }     } }  결과1  1 2 3 4 5 6 7 100:A 95:A 88:B 70:C 52:D 60:D 70:C     double 배열 limits는 범위의 경계값을 저장하는데 사용되었고, String 배열 grades는 범위에 포함될 값을 치환할 문자열을 저장하는데 사용되었다.   경계값은 double형으로 반드시 모두 오름차순으로 정렬되어있어야 한다.   치환될 문자열의 개수는 경계값에 의해 정의된 범위의 개수와 일치해야 한다.   위의 두 조건을 만족하지 않으면 IllegalArgumentException이 발생한다.   패턴 사용  예시2  1 2 3 4 5 6 7 8 9 10 11 12 13 import java.text.ChoiceFormat;  public class ChoiceFormatEx2 {     public static void main(String[] args){         String pattern = \"60#D|70#C|80#B|90#A\";         int[] scores = {91, 90, 80, 88, 70, 52, 60};          ChoiceFormat form = new ChoiceFormat(pattern);         for(int i = 0;i&lt;scores.length;i++){             System.out.println(scores[i] + \":\" + form.format(scores[i]));         }     } }  결과2  1 2 3 4 5 6 7 91:A 90:A 80:B 88:B 70:C 52:D 60:D     예시1에서 두 배열(limits, grades)을 사용하여 문자열을 처리한 것과 달리 예시2에서는 패턴을 사용하였다.   패턴은 구분자로 ‘#’와 ‘&lt;’ 두가지를 제공한다. ‘#’는 경계값을 범위에 포함시키고, ‘&lt;’는 포함시키지 않는다.   limit#value의 형태로 사용한다. ex)60&lt;D|70&lt;C|80&lt;B|90&lt;A  ","categories": ["java"],
        "tags": ["java","formatting class","ChoiceFormat"],
        "url": "/java/java-ChoiceFormat/",
        "teaser": null
      },{
        "title": "JAVA - DecimalFormat",
        "excerpt":"형식화 클래스?   ⚠ 이 글은 '자바의 정석'과 다른 인터넷의 글들을 참고하여 작성되었습니다 ⚠      숫자, 날짜, 텍스트 데이터를 일정한 형식에 맞게 표현할 수 있는 방법을 객체지향적으로 설계하여 표준화한 클래스.   형식화 클래스는 형식화에 사용될 패턴을 정의하는데, 데이터를 정의된 패턴에 맞춰 형식화할 수 있을 뿐만 아니라 역으로 형식화된 데이터에서 원래의 데이터를 얻어낼 수도 있다.   java.text패키지에 포함되어 있다.   DecimalFormat     숫자를 형식화하는 형식화 클래스.   숫자 데이터를 정수, 부동소수점, 금액 등의 다양한 형식으로 표현할 수 있다.   반대로 일정한 형식의 텍스트 데이터를 숫자로 쉽게 변한할 수도 있다.   DecimalFormat의 패턴에 사용되는 기호                  기호       의미       패턴       결과                       0       10진수(값이 없을 떄는 0)       0 0.0 0000000000.0000       1234568 1234567.9 0001234567.8900                 #       10진수       # #.# ##########.####       1234568 1234567.9 1234567.89                 .       소수점       #.#       1234567.9                 -       음수부호       #.#- -#.#       1234567.9- -1234567.9                 ,       단위 구분자       #,###,## #,####,##       1,234,567,89 123,4567,89                 E       지수기호       #E0 0E0 ##E0 00E0 ####E0 0000E0 #.#E0 0.0E0 0.000000000E0 00.00000000E0 000.0000000E0 #.#########E0 ##.########E0 ###.#######E0       .1E7 1E6 1.2E6 12E5 123.5E4 1235E3 1.2E6 1.2E6 1.234567890E6 12.34567890E6 123.4567890E4 1.23456789E6 1.23456789E6 1.23456789E6                 ;       패턴구분자       #.###.##+;#.###.##-       1.234.567.89+(양수일 때) 1.234.567.89-(음수일 때)                 %       퍼센트       #.#%       123456789%                 \\u2030       퍼밀(퍼센트 x 10)       #.#\\u2030       1234567890%                 \\u00A4       통화       \\u00A4 #,###       ₩ 1,234,568                 ’       escape문자       ’#’#,### ”#,###       #1,234,568 ‘1,234,568           DecimalFormat의 사용방법     원하는 출력형식의 패턴을 작성하여 DecimalFormat인스턴스를 생성한 다음, 출력하고자 하는 문자열로 format메서드를 호출하면 변환된 문자열을 얻을 수 있다   예시예2  1 2 3 4 double number = 1234567.89; DecimalFormat df = new DecimalFormat(\"#.#E0\"); String result = df.format(number); System.out.println(result);  결과2  1 1.2E6  ","categories": ["java"],
        "tags": ["java","Decimal class","ChoiceFormat"],
        "url": "/java/java-DecimalFormat/",
        "teaser": null
      },{
        "title": "JAVA - MessageFormat",
        "excerpt":"MessageFormat   ⚠ 이 글은 '자바의 정석'과 다른 인터넷의 글들을 참고하여 작성되었습니다 ⚠      MessageFormat은 데이터를 정해진 양식에 맞게 출력할 수 있게 해준다.   SimpleDateFormat의 parse처럼 MessageFormat의 parse를 이용하면 지정된 양식에서 필요한 데이터만을 추출할 수 있다.   데이터를 출력  예시1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.text.MessageFormat;  public class MessageFormatEx1 {     public static void main(String[] args){         String msg = \"Name: {0} \\nTel: {1} \\nAge:{2} \\nBirthday:{3}\";          Object[] arguments = {                 \"이자바\", \"02-123-1234\", \"27\", \"07-09\"         };          String result = MessageFormat.format(msg, arguments);         System.out.println(result);     } }     MessageFormat에 사용할 양식인 문자열 msg를 작성할 때 ‘{숫자}’로 표시된 부분이 데이터가 출력될 자리이다.   이 자리는 순차적일  필요는 없고, 여러 번 반복해서 사용할 수도 있다.   사용되는 숫자는 배열처럼 인덱스가 0부터 시작하며, 양식에 들어갈 데이터는 객체배열인 arguments에 지정되어 있다.   arguments는 객체배열이므로 String 이외에도 다른 객체들이 지정될 수 있으며, 이 경우 세부적인 옵션들이 사용될 수 있다.   데이터를 추출  예시2  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.text.MessageFormat;  public class MessageFormatEx3 {     public static void main(String[] args) throws Exception{         String[] data = {                 \"INSERT INTO CUST_INFO VALUES ('이자바', '02-123-1234', 27, '07-09');\",                 \"INSERT INTO CUST_INFO VALUES ('김프로', '032-333-1234', 33, '10-07');\",         };          String pattern = \"INSERT INTO CUST_INFO VALUES (''{0}'', ''{1}'', {2}, ''{3}'');\";         MessageFormat mf = new MessageFormat(pattern);          for(int i = 0; i &lt; data.length;i++){             Object[] objs = mf.parse(data[i]);             for(int j = 0; j &lt; objs.length; j++)                 System.out.print (objs[j] + \",\");             System.out.println();         }     } }     parse(String source)를 이용하여 출력된 데이터로부터 필요한 데이터만을 추출하였다.   홀따옴표(‘)는 MessageFormat 양식의 escape문자로 사용되기 때문에 문자열 pattern에 홀따옴표를 사용하려면 홀따옴표를 연속으로 두번 사용해야 한다.  ","categories": ["java"],
        "tags": ["java","formatting class","MessageFormat"],
        "url": "/java/java-MessageFormat/",
        "teaser": null
      },{
        "title": "JAVA - SimpleDateFormat",
        "excerpt":"SimpleDateFormat     Date와 Calendar만으로 날짜 데이터를 원하는 형태로 다양하게 출력하는 것은 불편하다.   SimpleDateFormat을 사용하면 날짜 데이터를 원하는 형태로 다양하게 출력할 수 있다.   SimpleDateFormat의 패턴에 사용되는 기호  ⚠ 이 글은 '자바의 정석'과 다른 인터넷의 글들을 참고하여 작성되었습니다 ⚠                  기호       의미       보기                       G       연대(BC, AD)       AD                 y       연도       2006                 M       월(1~12 또는 1월~12월)       10 또는 10월, OCT                 w       년의 몇 번째 주(1~53)       50                 W       월의 몇 번째 주(1~53)       5월                 D       년의 몇 번째 일(1~366)       100                 d       월의 몇 번쨰 일(1~31)       15                 F       월의 몇 번쨰 요일(1~5)       1                 E       요일       월                 a       오전/오후(AM, PM)       PM                 H       시간(0~23)       20                 k       시간(1~24)       13                 K       시간(0~11)       10                 h       시간(1~12)       11                 m       분(0~59)       35                 s       초(0~59)       55                 S       천분의 일초(0~999)       253                 z       Time zone(RFC 822 time zone)       +0900                 ’       escape문자(특수문자를 표현하는데 사용)       없음           SimpleDateFormat의 사용 방법     SimpleDateFormat을 사용하려면 원하는 패턴을 작성하여 SimpleDateFormat인스턴스를 생성한 뒤, 출력하고자 하는 Date인스턴스를 가지고 format(Date d)메소드를 호출하면 지정한 출력형식에 맞게 변환된 문자열을 얻게 된다.   예시  1 2 3 4 5 6 Date today = new Date(); SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");  // 오늘 날짜를 yyyy-MM-dd 형태로 변환하여 반환한다. String result = df.format(today); System.out.println(result);  결과  1 2024-01-20  ","categories": ["java"],
        "tags": ["java","formatting class","SimpleDateFormat"],
        "url": "/java/java-SimpleDateFormat/",
        "teaser": null
      },{
        "title": "Blog - github 페이지를 이용하여 블로그를 만든 이야기",
        "excerpt":"github page를 이용하여 블로그를 만든 이야기  어쩌다가 이 글을 읽게 되었다면, 당신은 아마도 블로그를 개설해야겠다고 마음을 먹었거나, 현재 블로그를 운영하고 있다거나, 블로그를 운영한 경험이 있을 것이다. 어쨌든 블로그에 관심이 있는 사람일 것이라는 말이다. 그런 당신에게 깃허브 블로그를 만들어가며 든 생각들을 공유하고자 한다. 이 글은 블로그 개설 방법을 공유하는 글은 아니다. 그런 글들은 검색하면 쉽게 다른 블로그들에서 쉽게 찾을 수 있을 것이다(혹시, minimal mistakes 테마를 사용했고, 사이드바 네이게이션에 글 수를 추가하고 싶다면, 내 블로그의 글을 참고하는 것도 도움이 될 것이다!). 이 글에는 블로그를 만들면서 겪은 경험들과 전체적인 생각들을 위주로 전달하고자 한다. 당신이 깃허브 페이지 블로그에 대한 고민을 한다면, 어쨌든 도움이 되긴 할 것이다!   블로그를 만들게 된 이유  이전부터 글을 쓸 수 있는 블로그를 만들고자 하는 생각은 있었지만, 블로그를 만들고 글을 쓰는 것은 꽤나 귀찮은 일이었기에 차일 피일 미루고만 있었다. 하지만, 공부한 것들을 슬슬 잊어버리면서, 내용을 정리하고 쉽게 꺼내 볼 수 있도록 해야겠다는 다각이 들었다(여기까지는 노션이면 충분하다). 추가로, 기왕이면 다른 사람한테 보여줄 수 있다면 미래의 취업에 더 도움이 될 것이라는 생각 또한 들어서 블로그를 만들게 되었다.   왜 깃허브 페이지를 선택했나?  이전부터 깃허브의 블로그를 이용한 블로그들이 존재하는 것은 알고 있었다. 과제나 프로젝트를 진행하며 여러 블로그들을 찾아 볼 때, ‘github’가 주소에 들어가있는 블로그들을 본 적이 있기 때문이다. 그 때는 크게 관심이 있는 것은 아니지만 특이하다 정도로 생각했던 것 같다. 이후에 블로그를 만들려고 여러 플랫폼을 알아보다보니, 그것이 ‘Github Page’를 이용한 블로그라는 것을 알게 되었고, 매우 강력한 커스텀 기능, 마크다운으로 작성하는 포스팅 등에 이점을 느껴 선택하게 되었다. 일반적인 블로그와는 다르다는 느낌이 조금 더 매력있게 다가왔던 것 같다.   그 길은 험난한 길이었고…  일반적인 블로그들과 달리, 깃허프 페이지 블로그는 스스로 만들어야 한다. 깃허브 페이지 블로그를 개설하기 위해서는 공식 문서와 블로그들을 뒤져야했다. 다른 블로그들의 도움 덕분에 이 블로그를 만들 수 있었지, 공식 문서만 있었다면 포기했을 것 같다. 그런데 특이한 점은 깃허브 페이지에 대한 상당수의 글들은 velog, tistory 등과 같은 다른 블로그 플랫폼에 작성되어 있었다. 정말 많은 도움이 된 한 블로그는 자기소개에 velog로 이전하다는 안내문이 적혀 있었다. 여기서 뭔가 이상한 것을 느꼈어야 했는데! 블로그를 개설한 뒤, 블로그에 필요한 기본적인 기능을 갖추고, 아주 약간에 커스텀을 하는데는 꽤나 많은 시간이 들었다. 단순히 설정하는 것이 아니라 약간의 개발을 하고 있다는 생각까지 들었다(ruby, css 코드까지 직접 건들긴 했으니까. 학교에서 들은 웹프로그래밍 수업이 없었다면 커스텀은 진작에 포기했을 것 같다). 또한 지금까지 해결하지 못한 문제도 있다. 꼭 필요한 것은 아니지만, 블로그에 분석 기능을 넣기 위해서, google analytics를 연동 하고 싶은데 아직까지도 실패했다. 이 문제를 해결한 경험 있는 분이 계시다면 댓글을 주셔도 되고, 이메일을 주셔도 좋으니 제발 도움을 주셨으면 좋겠다. 설정 파일도 만들고, 계정도 다시 파고, 별의 별 짓을 다하고 몇일 붙잡아도 되지 않는다. 매우 열받지만 꼭 필요한 기능은 아니니까 일단은 보류하기로 했다. 블로그로 돈버는건 아니니까…..   그래서 지금은?  어느 정도 설정을 하고, 모양을 갖추니, 이미 애정이 많이 들어버렸다. 어제는 블로그의 외형을 바꾸기 위해서 새벽까지 자지 못했는데, 노력한 만큼 확실히 애정이 빨리 든 것 같다. 마크다운으로 글을 작성하는 것도 익숙해져서 편하다. 하지만 한편에는 불안한 마음이 있다. “내가 설정한 기능이 잘 작동할까?”라는 생각이 계속해서 든다. 특히 google search console을 통한 노출이 잘 되는 것일까? 하는 생각이 든다. 지금까지 쓴 글이 6개인데 노출된 글은 하나이기 때문이다… 아직 작성한지 얼마 안되서 그런가싶기도 하고? 잘 모르겠다. 설정에 실패한 google analytics가 이런 불안감을 더 크게 만드는 것 같다(다시 한번 부탁드린다. 이 문제를 겪거나 해결하신 분은 댓글이나 이메일 부탁드린다. 저 절박해요…)  어쨌든 열심히 블로그를 만든 김에 공부한 내용도 정리하고, 이 글처럼 생각을 정리하고 공유하는 글도 많이 쓰고 싶다. 이 글을 쓰면서 글을 쓰는 것은 꽤 재미있는 일이라고 오랬만에 느낀 것 같다.  ","categories": ["Blog"],
        "tags": ["blog","github page","jekyll","minimal mistake"],
        "url": "/blog/blog-after-creating-blog/",
        "teaser": null
      }]
